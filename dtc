#!/usr/bin/env python
import re
import code
from datetime import datetime
from datetime import timedelta

replace = lambda replacee,replacer,string: re.sub(replacee, replacer, string)

tokens = (
    'PLUS','MINUS','EQUALS',
    'LPAREN','RPAREN',
    'TIME_INVALID',
    'TIME_MS',
    'TIME_HM',
    'TIME_HMS',
    # 'N', # now
    'T', # today
    'DATE', 
    'PERIOD', 
    # 'DATETIME', 
    'DELTA', 
    'NAME',
    )

# Tokens

t_PERIOD    = r'\.'
t_PLUS      = r'\+'
t_MINUS     = r'-'
t_EQUALS    = r'='
t_LPAREN    = r'\('
t_RPAREN    = r'\)'
t_NAME      = r'[a-zA-Z_][a-zA-Z0-9_]*'

def t_DELTA(t):
    r'((\d+)([smhdSMHD]))+'
    units_vals = { 
            u.lower():int(v) for v,u in re.findall('(\d+)([smhdSMHD])', t.value) 
            }
    t.value = timedelta()
    if 's' in units_vals:
        t.value += timedelta(seconds=units_vals['s'])
    if 'm' in units_vals:
        t.value += timedelta(minutes=units_vals['m'])
    if 'h' in units_vals:
        t.value += timedelta(hours=units_vals['h'])
    if 'd' in units_vals:
        t.value += timedelta(days=units_vals['d'])
    return t

def t_T(t):
    r'T'
    t.value = datetime.today()
    return t

def t_N(t):
    r'N'
    t.value = datetime.now()
    return t

def t_TIME_HMS(t):
    r'(2[0-4]|[01][0-9]):(60|[0-5][0-9]):(60|[0-5][0-9])'
    t.value = datetime.strptime(t.value, '%H:%M:%S')
    return t

def t_TIME_INVALID(t):
    r'\d+:\d+'
    print(f'Ambiguous time definition')
    return t

def t_TIME_MS(t):
    r'(2[0-4]|[01][0-9])[mM]:(60|[0-5][0-9])[sS]'
    t.value = datetime.strptime(replace('m|s', '', t.value), '%M:%S')
    return t

def t_TIME_HM(t):
    r'(2[0-4]|[01][0-9])[hH]:(60|[0-5][0-9])[mM]'
    t.value = datetime.strptime(replace('h|m', '', t.value), '%H:%M')
    return t

def t_DATE(t):
    r'\d+(\D)(1[0-2]|0[1-9])\2(3[01]|[12][0-9]|[1-9]) '
    t.value = datetime.strptime(replace(r'\D', '-', t), '%Y-%M-%D')
    return t

def t_DATETIME(t):
    r'\d+(\D)(1[0-2]|0[1-9])\2(3[01]|[12][0-9]|[1-9]) ' 
    t.value = datetime.strptime(replace(r'\D', '-', t), '%Y-%M-%D')
    return t

t_ignore = " \t"
t_ignore_COMMENT = r'\#.*'

def t_newline(t):
    r'\n+'
    t.lexer.lineno += t.value.count("\n")

def t_error(t):
    print(f"Illegal character {t.value[0]!r}")
    t.lexer.skip(1)

import ply.lex as lex
lex.lex()

precedence = (
    ('left','PLUS','MINUS'),
    ('right','UMINUS'),
    )


days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
names = { 
            'dow': lambda t: days[t.weekday()]
        }

def p_statement_assign(p):
    'statement : NAME EQUALS expression'
    names[p[1]] = p[3]

def p_statement_expr(p):
    'statement : expression'
    if p[1]:
        print(p[1])

def p_expression_binop(p):
    '''expression : expression PLUS expression
                  | expression MINUS expression'''
    if   p[2] == '+': p[0] = p[1] + p[3]
    elif p[2] == '-': p[0] = p[1] - p[3]

def p_expression_uminus(p):
    'expression : MINUS expression %prec UMINUS'
    p[0] = -p[2]

def p_expression_name(p):
    'expression : NAME'
    try:
        p[0] = names[p[1]]
    except LookupError:
        print(f"Undefined name {p[1]!r}")

def p_expression_funcall(p):
    'expression : NAME expression'
    p[0] = names[p[1].lower()](p[2])

def p_expression_get_attribute(p):
    'expression : expression PERIOD NAME'
    p[0] = names[p[3]](p[1])

def p_expression_invalid_time(p):
    'expression : TIME_INVALID'

def p_expression_datetime(p):
    '''expression : TIME_MS 
                  | TIME_HM
                  | TIME_HMS
                  | DATE
                  | DELTA
                  | T'''
    p[0] = p[1]

def p_expression_group(p):
    'expression : LPAREN expression RPAREN'
    p[0] = p[2]

def p_error(p):
    print(f'Syntax error at {p.value!r}')
    exit(1)

import ply.yacc as yacc
yacc.yacc()

import cmd

class CmdParse(cmd.Cmd):
    prompt = ''
    commands = []
    def do_list(self, line):
        print(self.commands)
    def default(self, line):
        if line == 'EOF':
            exit(0)
        yacc.parse(line)
        self.commands.append(line)
    def do_exit(self, line):
        return True
CmdParse().cmdloop()
