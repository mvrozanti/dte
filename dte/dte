#!/usr/bin/env python
from collections import OrderedDict
from datetime import datetime, date, timedelta, time
from dateutil.relativedelta import relativedelta
from ply.lex import TOKEN
from time import sleep, mktime
from types import SimpleNamespace as Namespace
import appdirs
import code
import json
import locale
import os
import os.path as op
import re
import sys
import types

def read_write_get_config():
    config_dir = appdirs.user_config_dir()
    dte_config_dir = config_dir + '/dte'
    dte_config_file = dte_config_dir + '/config.json'
    default_config = { 
            'timestamp_unit': 'seconds',
            'datetime_output_format': 'ISO8601' 
            }
    if not op.exists(dte_config_dir):
        os.mkdir(dte_config_dir)

    if op.exists(dte_config_file):
        try:
            config_dict = json.load(open(dte_config_file))
        except Exception:
            print('Configuration file is malformed.\n'+\
                    'Falling back to default configuration', file=sys.stderr)
            config_dict = default_config
    else:
        json.dump(default_config, open(dte_config_file, 'w'), indent=4)
        config_dict = default_config
    return config_dict

config = Namespace(**read_write_get_config())

HELP = '''
SYNTAX


OBJECTS

    DELTA  

            a timedelta object can be interpreted as 
            chain of (amount, unit) consisting of a 
            number followed by a time unit in ISO format, 
            with case input relaxed except for 
            differentiating months and minutes:

                1D+1d  # case insensitive
                3m+3M  # except for months and minutes
               -2M+2s  # accepts negative numbers
                10Y3s  # join them together instead of adding

    DATETIME

            a datetime object represents a point in 
            time. Can be interpreted in various forms 
            such as follows:

                1611269086 # unix timestamp in seconds
                2020/12/31 22:22
                2020 Jan 12
                2020 December 20
                2020/12/31 22:22:22
                2020/12/31
                today

VARIABLES

            there are three built-in variables:

                T or today     
                YD or yesterday
                TM or tomorrow 
                N  or now      

            but you can also assign objects to a 
            named variable, like so:
                foo=1d
                bar=YD

OPERATORS
            +  : adds deltas to points in time
            -  : takes de difference between two points 
                 in time and stores a delta

 <,<=,>,==,!=  : compares two points in time and returns
                 a boolean

KEYWORDS
            in :  

FUNCTIONS / ATTRIBUTES 
              
    wait DELTA       : sleeps for the duration

    next WEEKDAY     : returns the date for the next weekday

    last WEEKDAY     : returns the date for the last weekday

dayofweek TIME_POINT : returns weekday for time point
    dow  TIME_POINT  : ⏎
    TIME_POINT.dow   : ⏎

STDIN

       The  standard  input  shall be used only if no arguments are specified.

'''

n = None

replace = lambda replacee,replacement,string: re.sub(replacee, replacement, string)

days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']
months = ['January', 'February', 'March', 'April', 'May', 'June', \
            'July', 'August', 'September', 'October', 'November', 'December']
days_abbrev = [d[:3] for d in days]
months_abbrev = [m[:3] for m in months]

tokens = (
    'PLUS','MINUS','EQUALS',
    'LPAREN','RPAREN',
    'YD', # yesterday
    'N',  # now
    'T',  # today
    'TM', # tomorrow
    'UNIT',
    'CYCLIC_OP',
    'IN',
    'GT', 'GE', 'LT', 'LE', 'EQ', 'NE',
    'NAME',
    'DELTA', 
    'TIMESTAMP', 
    'WEEKDAY', 
    'PERIOD', 
    'SEMICOLON', 
    'COLON', 
    'DATETIME', 
    )

# Tokens

t_COLON     = r':'
t_SEMICOLON = r';'
t_PERIOD    = r'\.'
t_PLUS      = r'\+'
t_MINUS     = r'-'
t_EQUALS    = r'='
t_LPAREN    = r'\('
t_RPAREN    = r'\)'
t_GT        = r'>'
t_GE        = r'>='
t_LT        = r'<'
t_LE        = r'<='
t_EQ        = r'=='
t_NE        = r'!='
t_IN        = r'(?i)in'

unit_map = {
        's': 'seconds',
        'S': 'seconds',
        'M': 'minutes',
        'h': 'hours',
        'H': 'hours',
        'd': 'days',
        'D': 'days',
        'w': 'weeks',
        'W': 'weeks',
        'm': 'months',
        'y': 'years',
        'Y': 'years',
        }

reserved = [
            r'in',
            r'n(ow)?',
            r't(oday)?',
            r'next|last',
            r'yd|yesterday',
            r'seconds|minutes|hours|days|weeks',
            '|'.join(days),
            '|'.join(days_abbrev),
            '|'.join(months),
            '|'.join(months_abbrev),
        ]

def is_reserved(k):
    for r in reserved:
        if re.match(r, k):
            return True

REGEX_DOY = r'(?:\d+(?!:)(?:\W)\d+(?!:)(?:\W)\d+|\d+[\W\s]+(?:' + '|'.join(months) + '|' + '|'.join(months_abbrev) + r')[\W\s]+\d+)'
REGEX_0_23 = r'(?:2[0-3]|1?[0-9]|00)'
REGEX_0_59 = r'(?:[0-5]?[0-9])'

DATETIME_REGEX = f'(?:({REGEX_DOY})'+r'\s'+f'?|(?:({REGEX_0_59})([hHM])?):(?:({REGEX_0_59})([MsS])?)(?::(?:({REGEX_0_59})([sS])?))?(?:'+r'\s+([aA]|[pP])[mM])?)' + '{1,2}'
@TOKEN(DATETIME_REGEX)
def t_DATETIME(t):
    date_str,\
    first_val,\
    first_unit,\
    second_val,\
    second_unit,\
    third_val,\
    third_unit,\
        ampm = re.search(DATETIME_REGEX, t.value).groups()
    if t.value.count(':') == 1 and \
            not first_unit and not second_unit \
            and not third_unit and not third_val:
            raise Exception(f'did you mean {first_val}h:{second_val} or '+\
                                          '{first_val}M:{second_val}?')

    if ampm is not None and \
            (first_unit == 'h' or \
                first_unit == 'H' or \
                second_unit == 'M' or \
                third_val) and \
                int(first_val ) > 12:
                    raise Exception('conflicting 24-hour clock with 12-hour clock')

    if date_str:
        if any(month in date_str for month in months_abbrev):
            y,b,d = replace('[\W\s]+', ' ', date_str).split(' ')
            try:
                date = datetime.strptime(f'{y.zfill(4)}-{b}-{d}', '%Y-%b-%d')
            except:
                try:
                    date = datetime.strptime(f'{y.zfill(4)}-{b}-{d}', '%Y-%B-%d')
                except:
                    raise Exception(f'Invalid syntax: {date_str}')
        else:
            y,m,d = replace(r'\D', '-', date_str).split('-')
            date = datetime.strptime(f'{y.zfill(4)}-{m}-{d}', '%Y-%m-%d').date()
        if (first_val,second_val,third_val) == (None,None,None):
            t.value = date
            return t
    else:
        date = datetime.today()
    is_HMS = t.value.count(':') == 2
    is_HM = 'h' == first_unit or \
            'H' == first_unit or \
            'M' == second_unit or \
            (third_unit is not None and \
                ('s' == third_unit or 'S' == third_unit))
    if ampm is not None and \
            (first_unit == 'h' or first_unit == 'H' or \
                second_unit == 'M'):
                    if first_val != '12':
                        if ampm.lower() == 'p':
                            first_val = f'{(int(first_val)+12)}' 
                    else:
                        first_val = 0 if ampm.lower() == 'a' else '12'

    H_or_M,M_or_S,S = (first_val,second_val,third_val)
    if is_HMS:
        le_time = datetime.strptime(f'{H_or_M}:{M_or_S}:{S}', '%H:%M:%S').time()
    elif is_HM:
        le_time = datetime.strptime(f'{H_or_M}:{M_or_S}', '%H:%M').time()
    else:
        le_time = datetime.strptime(f'{H_or_M}:{M_or_S}', '%M:%S').time()
    t.value = le_time if not date_str else datetime.combine(date,le_time)
    return t

UNITS_STR = 'sSMhHdDwWmyY'
FLOATING_POINT = r'((?:\d*[.])?\d+)'
DELTA_TOKEN = FLOATING_POINT + '['+UNITS_STR+']('+FLOATING_POINT+'(['+UNITS_STR+']|$))*'
@TOKEN(DELTA_TOKEN)
def t_DELTA(t):
    units_vals = OrderedDict()
    matches = re.findall(FLOATING_POINT + '(['+UNITS_STR+']|$)', t.value)
    for v,u in matches:
        units_vals.update({ u if u in 'mM' else u.lower(): float(v) if v else 1 })
    t.value = parse_units(units_vals)
    if '' in units_vals:
        u,_ = list(units_vals.items())[list(units_vals.keys()).index('')-1]
        next_unit = UNITS_STR[UNITS_STR.index(u)-1]
        if next_unit.lower() == u.lower():
            next_unit = UNITS_STR[UNITS_STR.index(u)-2]
        le_add = parse_units({next_unit: units_vals['']}) # get successor delta
        t.value += le_add
    return t

t_NAME = '(?i)(' + ''.join([f'(?!{res})' for res in reserved]) + '[a-z_][a-z0-9_]*)'

@TOKEN(r'(?i)' + '|'.join(days) + '|' + '|'.join(days_abbrev))
def t_WEEKDAY(t):
    t.value = Weekday(t.value)
    return t

@TOKEN(r'(?i)' + '|'.join(months) + '|' + '|'.join(months_abbrev))
def t_MONTH(t):
    t.value = Month(t.value)
    return t

def t_CYCLIC_OP(t):
    r'(?i)(next|last)'
    return t

def t_UNIT(t):
    r'(?i)(seconds|minutes|hours|days|weeks|months|years|unix)'
    return t

def t_YD(t):
    r'(?i)(yesterday|yd)'
    t.value = (datetime.today() - timedelta(days=1)).date()
    return t

def t_TM(t):
    r'(?i)(tomorrow|tm)'
    t.value = (datetime.today() + timedelta(days=1)).date()
    return t

def t_T(t):
    r'(?i)t(oday)?'
    t.value = date.today()
    return t

def t_N(t):
    r'(?i)n(ow)?'
    global n
    if not n:
        n = datetime.now()
    t.value = n
    return t

def get_closest_week_day(week_day):
    counter_next = 0
    counter_prev = 0
    next_date = datetime.now()
    for _ in range(7):
        next_date += timedelta(days=1)
        counter_next += 1
        if days[next_date.weekday()].lower() == week_day.lower():
            break
    prev_date = datetime.now()
    for _ in range(7):
        prev_date += timedelta(days=-1)
        counter_prev += 1
        if days[prev_date.weekday()].lower() == week_day.lower():
            break
    if counter_next < counter_prev:
        return next_date.date()
    return prev_date.date()

def parse_units(units_vals):
    parsed = timedelta()
    for unit,long_name in unit_map.items():
        if unit in units_vals:
            if unit.lower() == 'y':
                parsed += (datetime.now()+relativedelta(years=units_vals[unit])) - datetime.now()
            elif unit == 'm':
                parsed += (datetime.now()+relativedelta(months=units_vals[unit])) - datetime.now()
            else:
                parsed += timedelta(**{long_name: units_vals[unit]})
    return parsed

def t_TIMESTAMP(t):
    r'\d+'
    t.value = datetime.fromtimestamp(int(t.value) if config.timestamp_unit == 'seconds' else int(t.value)/1000)
    return t

t_ignore = ' \t'
t_ignore_COMMENT = r'\#.*'

def t_newline(t):
    r'\n+'
    t.lexer.lineno += t.value.count('\n')

def t_error(t):
    print(f'illegal character {t.value[0]!r}',file=sys.stderr)
    t.lexer.skip(1)

import ply.lex as lex
lex.lex(debug=False)

def wait(t):
    if isinstance(t, datetime):
        now = datetime.now()
        delta = t - now
    elif isinstance(t, timedelta):
        delta = t
    else:
        raise Exception('wait accepts a time point or time delta only')
    if delta > timedelta(0):
        sleep(delta.total_seconds())

def last_wd(t):
    prev_date = datetime.now()
    for _ in range(7):
        prev_date += timedelta(days=-1)
        if days[prev_date.weekday()].lower() == str(t).lower():
            break
    return prev_date.date()

def cyclic(t, direction):
    cyclic_direction = datetime.now()
    for _ in range(7):
        cyclic_direction += timedelta(days=direction)
        if days[cyclic_direction.weekday()].lower() == str(t).lower():
            break
    return cyclic_direction.date()

def dow(t):
    if type(t) == date or type(t) == datetime:
        return days[t.weekday()]
    elif type(t) == timedelta:
        return days[(datetime.now()+t).weekday()]
    else:
        raise Exception('can\'t get day of week of object of type' + str(type(t)))

def is_000(obj):
    return obj.hour == obj.minute == obj.second == 0 if type(obj) == datetime \
            else type(obj) == date 

class Weekday:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

class Month:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return self.name

names = {
            'day'       : lambda t                           : t.day,
            'month'     : lambda t                           : t.month,
            'year'      : lambda t                           : t.year,
            'hour'      : lambda t                           : t.hour,
            'minute'    : lambda t                           : t.minute,
            'second'    : lambda t                           : t.second,

            'wait'      : lambda t                           : wait(t),
            'dow'       : lambda t                           : dow(t),
            'dayofweek' : lambda t                           : dow(t),
            'weekday'   : lambda t                           : dow(t),
            'help'      : lambda                             : print(HELP),
        }

precedence = (
    ('left',
        'IN', 
        ),
    ('right',
        'UMINUS',
        ),
    ('left',
        'PLUS',
        'MINUS', 
        ),
    )

def p_statements(p):
    'statement : statement SEMICOLON statement'

def p_statement_invalid_assignment(p):
    'statement : WEEKDAY EQUALS expression'
    raise Exception('can\'t assign expression to weekday')

def p_statement_assign(p):
    'statement : NAME EQUALS expression'
    global n
    n = None
    if is_reserved(p[1]):
        raise Exception('can\'t use reserved keyword')
    names[p[1]] = p[3]

def normalize(t):
    if type(t) == datetime and \
            is_000(t):
        t = t.date()
    return t

def p_statement_expr(p):
    'statement : expression'
    if type(p[1]) is Weekday:
        p[1] = get_closest_week_day(str(p[1]))
    if p[1] is not None:
        if config.datetime_output_format != 'ISO8601':
            print(normalize(p[1]).strftime(config.datetime_output_format))
        else:
            print(normalize(p[1]))
        names['_'] = p[1]

def time2timedelta(n):
    return timedelta(hours=n.hour, minutes=n.minute, seconds=n.second) 

def p_expression_binop(p):
    '''expression : expression PLUS expression
                  | expression MINUS expression
                  '''

    if type(p[1]) == time and type(p[3]) == timedelta:
        p[1] = time2timedelta(p[1])

    if type(p[3]) == time and type(p[1]) == timedelta:
        p[3] = time2timedelta(p[3])

    if type(p[1]) == date and type(p[3]) == timedelta:
        p[1] = datetime.combine(p[1], datetime.min.time())

    if type(p[3]) == date and type(p[1]) == timedelta:
        p[3] = datetime.combine(p[3], datetime.min.time())

    if type(p[1]) == date and type(p[3]) == datetime:
        p[1] = datetime.combine(p[1], datetime.min.time())

    if type(p[3]) == date and type(p[1]) == datetime:
        p[3] = datetime.combine(p[3], datetime.min.time())

    if p[1] is None or p[3] is None:
        raise Exception(f'in {p[2]} expr, p[1]={p[1]} and p[3]={p[3]}')

    if type(p[1]) == Weekday:
        p[1] = get_closest_week_day(str(p[1]))
    if type(p[3]) == Weekday:
        p[3] = get_closest_week_day(str(p[3]))
    if   p[2] == '+': 
        p[0] = p[1] + p[3]
    elif p[2] == '-': 
        p[0] = p[1] - p[3]

def p_expression_comparison(p):
    '''expression : expression GT expression
                  | expression LT expression
                  | expression GE expression
                  | expression LE expression
                  | expression EQ expression
                  | expression NE expression
                  '''

    if type(p[1]) == date and type(p[3]) == datetime:
        p[1] = datetime.combine(p[1], datetime.min.time())

    if type(p[3]) == date and type(p[1]) == datetime:
        p[3] = datetime.combine(p[3], datetime.min.time())

    try:
        if p[2] == '<':
            p[0] = p[1] < p[3]
        if p[2] == '>':
            p[0] = p[1] > p[3]
        if p[2] == '>=':
            p[0] = p[1] >= p[3]
        if p[2] == '<=':
            p[0] = p[1] <= p[3]
        if p[2] == '==':
            p[0] = p[1] == p[3] or (p[3] - p[1]).total_seconds() < .0001
        if p[2] == '!=':
            p[0] = p[1] != p[3]
        if type(p[1]) == datetime and \
                is_000(p[1]):
                    p[1] = p[1].date()
        if type(p[3]) == datetime and \
                is_000(p[3]):
                    p[3] = p[3].date()
    except TypeError as e:
        print(str(e))

def p_expression_funcall(p):
    'expression : NAME expression'
    try:
        p[0] = names[p[1].lower()](p[2])
    except:
        raise Exception("Undefined name '%s'" % p[1])

def p_expression_cyclic_op(p):
    'expression : CYCLIC_OP WEEKDAY'
    p[0] = cyclic(p[2], 1 if p[1] == 'next' else -1)

def p_expression_point_in_unit(p):
    'expression : expression IN UNIT'
    to_unix = p[3] == 'unix'
    if type(p[1]) == timedelta and to_unix:
        raise Exception('can\'t convert timedelta to unix timestamp')
    if to_unix:
        p[0] = int(mktime(p[1].timetuple()))
    if p[3].lower() in unit_map.values():
        total_seconds = p[1].total_seconds()
        if p[3] == 'seconds':
            p[0] = total_seconds
        if p[3] == 'minutes':
            p[0] = total_seconds / 60
        if p[3] == 'hours':
            p[0] = total_seconds / 60 / 60
        if p[3] == 'days':
            p[0] = total_seconds / 60 / 60 / 24
        if p[3] == 'weeks':
            p[0] = total_seconds / 60 / 60 / 24 / 7

def p_expression_generic(p):
    '''expression : DELTA 
                  | point
                  '''
    p[0] = p[1]

def p_point(p):
    '''point : N
             | T
             | TIMESTAMP
             | DATETIME
             | TM
             | WEEKDAY
             | YD
             '''
    p[0] = p[1]

def p_expression_name(p):
    'expression : NAME'
    try:
        p[0] = names[p[1]]
        if(type(p[0]) is types.LambdaType):
            p[0] = p[0]()
    except LookupError:
        try:
            p[0] = names[p[3]](p[1])
        except LookupError:
            print("Undefined name '%s'" % p[1])
            p[0] = 0

def p_expression_get_attribute(p):
    'expression : expression PERIOD NAME'
    p[0] = names[p[3]](p[1])

def p_expression_group(p):
    'expression : LPAREN expression RPAREN'
    p[0] = p[2]

def p_expression_uminus(p):
    'expression : MINUS expression %prec UMINUS'
    p[0] = -p[2]


import ply.yacc as yacc
yacc.yacc(errorlog=yacc.NullLogger())

def interactive():
    import cmd
    class CmdParse(cmd.Cmd):
        prompt = ''
        commands = []
        def default(self, line):
            if line == 'EOF':
                exit(0)
            yacc.parse(line)
            self.commands.append(line)
        def do_help(self, line):
            print(HELP)
        def do_exit(self, line):
            return True
    CmdParse().cmdloop()

if __name__ == '__main__':
    if len(sys.argv) > 1:
        yacc.parse(' '.join(sys.argv[1:]))
    else:
        interactive()
